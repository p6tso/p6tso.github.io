# extract_text_from_file

## 1. Валидация входных параметров

| Параметр | Источник | Тип данных | Обязательность | Проверка | Допустимые значения |
|----------|----------|------------|----------------|----------|---------------------|
| `file_path` | Внутренний вызов | String | Обязательно | Существующий путь к файлу | Абсолютный путь в /tmp/ |
| `mime_type` | Событие Kafka | String | Обязательно | Поддерживаемый тип | application/pdf, application/vnd.openxmlformats..., text/plain |
| `file_id` | Событие Kafka | String | Обязательно | Формат UUID | UUID v4 |
| `max_file_size` | Конфигурация | Integer | Опционально | ≤ 100MB | По умолчанию: 104857600 |

## 2. Подготовка к обработке

**Последовательные операции:**
1. Проверка существования файла по пути
2. Проверка размера файла (не превышает `max_file_size`)
3. Создание временной директории для промежуточных данных:
    - `{temp_dir}/{file_id}/processing/`
4. Инициализация метрик:
    - `start_time = time.now()`
    - `file_size = os.path.getsize(file_path)`

## 3. Диспетчеризация по типу файла

**Логика выбора процессора:**
```python
processor_map = {
    'application/pdf': PDFProcessor,
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': DOCXProcessor,
    'text/plain': TextProcessor,
    'text/markdown': TextProcessor,
    'text/csv': TextProcessor
}

```

## 4. PDF обработка (application/pdf)

### Алгоритм:
1. **Инициализация**:
    - Использование библиотеки `pdfplumber` или `PyPDF2`
    - Открытие файла в бинарном режиме
    - Проверка на password protection (ошибка, если защищен)

2. **Извлечение текста**:
    - Чтение каждой страницы по отдельности
    - Использование `extract_text()` для каждой страницы
    - Сохранение структуры: `[{"page": 1, "text": "...", "bbox": [...]}]`

3. **Обработка таблиц** (опционально):
    - Обнаружение таблиц через `extract_tables()`
    - Конвертация в текстовый формат (CSV-like)

4. **Сборка результата**:
    - Объединение текста всех страниц
    - Добавление разделителей страниц: `\n--- Page {n} ---\n`
    - Подсчет количества страниц

## 5. DOCX обработка

### Алгоритм:
1. **Инициализация**:
   
2. **Извлечение структуры**:
    - Обход всех параграфов: `document.paragraphs`
    - Извлечение текста с сохранением стилей (заголовки, списки)
    - Обработка таблиц через `document.tables`
    - Извлечение метаданных документа

3. **Форматирование**:
    - Заголовки: `# {text}` для Heading 1, `## {text}` для Heading 2
    - Списки: сохранение маркеров/нумерации
    - Таблицы: конвертация в markdown-таблицы

## 6. Текстовые файлы (TXT, MD, CSV)

### Алгоритм:
1. **Определение кодировки**:
    - Использование `chardet` для автоопределения
    - Fallback: UTF-8 → UTF-16 → CP1251

2. **Чтение файла**:
    - Открытие в соответствующей кодировке
    - Чтение построчно или целиком (в зависимости от размера)

3. **Очистка текста**:
    - Удаление BOM (Byte Order Mark)
    - Нормализация переносов строк
    - Удаление лишних пробелов

## 7. Постобработка текста

**Общие операции для всех типов:**
1. **Очистка**:
    - Удаление управляющих символов (ASCII < 32, кроме \t, \n, \r)
    - Замена множественных пробелов на один
    - Нормализация Unicode (NFKC)

2. **Валидация**:
    - Проверка минимальной длины (≥ 10 символов после очистки)
    - Проверка на бинарный контент (если 0 печатных символов → ошибка)
    - Проверка кодировки (валидный UTF-8)

3. **Статистика**:
    - Подсчет символов (с пробелами и без)
    - Подсчет слов
    - Подсчет строк
    - Определение языка (опционально, через langdetect)

## 8. Форматирование результата

**Структура результата:**
```json
{
    "success": True,
    "text": "извлеченный текст...",
    "metadata": {
        "original_length": len(original_text),
        "cleaned_length": len(cleaned_text),
        "pages": 15,  # для PDF
        "paragraphs": 42,  # для DOCX
        "encoding": "UTF-8",
        "language": "ru",  # если определен
        "processing_time_ms": 1234,
        "extractor_version": "1.0"
    },
    "warnings": [
        "Низкое качество OCR",  # если применимо
        "Не все таблицы распознаны"
    ]
}
```

**Для ошибок:**
```json
{
    "success": False,
    "text": None,
    "error": {
        "code": "CORRUPTED_PDF",
        "message": "PDF file is corrupted or password protected",
        "details": "Error at page 3: invalid xref table",
        "suggestion": "Try to repair the file or convert to another format"
    },
    "metadata": {
        "processing_time_ms": 234,
        "attempted_pages": 3  # если успели обработать частично
    }
}
```

## 9. Очистка временных данных

**Последовательные операции:**
1. Закрытие всех открытых файловых дескрипторов
2. Удаление временного файла обработки
3. Удаление директории `{temp_dir}/{file_id}/` если пустая
4. Запись в лог объема освобожденного места

## Ошибки извлечения

| Код ошибки | Условие | Причина | Возможное решение |
|------------|---------|---------|-------------------|
| `FILE_NOT_FOUND` | Файл не существует по пути | Ошибка передачи параметров | Проверить file_path |
| `FILE_TOO_LARGE` | Размер > max_file_size | Конфигурационное ограничение | Увеличить лимит или разбить файл |
| `UNSUPPORTED_TYPE` | Неподдерживаемый MIME-тип | .exe, .zip, .jpg и т.д. | Пропустить обработку |
| `CORRUPTED_PDF` | Поврежденный PDF | Невалидная структура | Попробовать другой ридер |
| `PASSWORD_PROTECTED` | Защищенный PDF | Требуется пароль | Не обрабатывать |
| `ENCODING_ERROR` | Неопределяемая кодировка | Бинарный файл или неизвестная кодировка | Пропустить обработку |
| `EXTRACTION_TIMEOUT` | Таймаут обработки | Слишком большой/сложный файл | Увеличить timeout или разбить |
| `MEMORY_ERROR` | Недостаточно памяти | Очень большой файл | Использовать streaming обработку |

