# Zombie-farm Frontend


## 1. Архитектурное разделение

### 1.1. Двойная архитектура (React + Phaser)
**React-слой:**
- Отвечает за пользовательский интерфейс
- Управляет страницами приложения (логин, главная)
- Обрабатывает меню, навигацию, формы
- Управляет состоянием UI (кроме игрового)

**Phaser-слой (игровой движок):**
- Полностью инкапсулированная игровая логика
- Отрисовывает графику в canvas
- Управляет игровыми объектами, физикой, анимациями
- Работает со сценами (scenes)

### 1.2. Принцип взаимодействия между слоями
- React рендерит контейнер (div), в который Phaser помещает canvas
- React получает информацию о текущей игровой сцене через глобальную переменную (используя useRef)
- React НЕ имеет доступа к внутренней логике Phaser
- Phaser НЕ имеет прямого доступа к React-компонентам

## 2. Поток инициализации и работы

### 2.1. Процесс загрузки приложения
```
1. Пользователь заходит на страницу
2. Загружаются React-компоненты
3. Инициализируется EventBus
4. EventBus ожидает подтверждения готовности Phaser
5. После подтверждения от EventBus:
   - React начинает рендеринг интерфейса
   - Phaser запускает Preloader сцену
   - Preloader загружает все необходимые ресурсы (картинки и т.д.)
6. После загрузки ресурсов Phaser переключается на игровые сцены
```

### 2.2. Процесс аутентификации
```
1. Пользователь переходит на страницу логина
2. Загружается Telegram Widget
3. Получаются два токена аутентификации
4. Токены периодически обновляются (раз в определенный тик)
5. При успешной аутентификации:
   - Пользователь перенаправляется на главную страницу
   - Главная страница автоматически запрашивает CSRF-ключ у сервера
   - После получения CSRF начинается загрузка игры
```

## 3. Системы коммуникации

### 3.1. Коммуникация с сервером
**Единый модуль `request.js`:**
- Содержит все функции для работы с GraphQL API
- Используется как React-компонентами, так и Phaser-кодом
- Обеспечивает консистентность API-вызовов
- Обрабатывает CSRF-токены (которые запрашиваются на главной странице)

**Поток CSRF:**
```
Главная страница → Запрос CSRF → Сервер → Сохранение → Все последующие запросы
```

### 3.2. Внутренняя коммуникация
**EventBus.js:**
- Система событий для координации между React и Phaser
- Гарантирует, что страница не будет отображаться до готовности движка
- Служит точкой синхронизации загрузки

**Глобальная переменная (useRef):**
- Единственный способ для React получить информацию из Phaser
- Передает данные о текущей активной сцене
- Ограниченный доступ (только чтение определенных данных)

## 4. Игровой процесс (Phaser)

### 4.1. Сценарная архитектура
```
Preloader (обязательная сцена)
├── Загружает все необходимые ресурсы
├── Картинки, звуки, анимации
└── После загрузки → переход к игровым сценам

Игровые сцены
├── Определены в коде, какая сцена когда вызывается
├── Каждая сцена имеет свою логику
└── Управляются движком Phaser
```

### 4.2. Изоляция игровой логики
- Весь игровой процесс происходит внутри canvas
- React видит только конечный результат отрисовки
- Игровые состояния и данные хранятся в Phaser
- События игры обрабатываются Phaser-движком

## 5. Особенности работы

### 5.1. Разделение ролей
**React отвечает за:**
- Отображение нефункциональных элементов интерфейса
- Навигацию между страницами
- Формы ввода данных
- Состояние приложения (кроме игрового)

**Phaser отвечает за:**
- Все игровые механики
- Графику и анимации
- Физику и коллизии
- Игровой прогресс и состояния

### 5.2. Технологический стек в действии
**Vite:**
- Обеспечивает быструю сборку во время разработки
- Реактивно обновляет страницы при изменениях кода
- Оптимизирует production-сборку

**React:**
- Строит компонентную архитектуру интерфейса
- Управляет жизненным циклом UI-компонентов

**Phaser 3:**
- Обеспечивает игровой движок с поддержкой TypeScript
- Имеет собственную систему управления ресурсами
- Предоставляет API для работы с графикой и физикой

### 5.3. Ограничения и особенности
- **Односторонняя связь:** React → Phaser (только отображение)
- **Минимальное взаимодействие:** Только через глобальную переменную
- **Раздельная загрузка:** Сначала React, потом Phaser через EventBus
- **Единый API-клиент:** Все запросы через один модуль

## 6. Поток данных

### 6.1. От сервера к клиенту
```
Сервер (GraphQL) → request.js → { React-компоненты, Phaser-код }
```

### 6.2. От клиента к серверу
```
{ React-формы, Phaser-действия } → request.js → Сервер (GraphQL)
```

### 6.3. Внутри клиента
```
React UI-события → React-обработчики
Phaser игровые события → Phaser-обработчики
Синхронизация через EventBus и глобальную переменную
```